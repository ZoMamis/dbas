

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Concept: The Supergraph &mdash; D-BAS 0.0.1 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="D-BAS 0.0.1 documentation" href="../index.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="../home.html" class="fa fa-home"> D-BAS</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="simple">
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../home.html">D-BAS</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../home.html">Docs</a> &raquo;</li>
      
    <li>Concept: The Supergraph</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../_sources/attic/supergraph.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="concept-the-supergraph">
<h1>Concept: The Supergraph<a class="headerlink" href="#concept-the-supergraph" title="Permalink to this headline">¶</a></h1>
<div class="section" id="our-terminology">
<h2>Our Terminology<a class="headerlink" href="#our-terminology" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">node</span></code></dt>
<dd>Building blocks of Adhocracy participation processes.  Examples:
&#8220;document&#8221;, &#8220;user&#8221;, &#8220;likes&#8221;, &#8220;vote&#8221;, etc.  Nodes can connect to
other nodes using references (see below).  They are implemented as
python objects.</dd>
<dt><code class="docutils literal"><span class="pre">reference</span></code></dt>
<dd><p class="first">A reference connects a source node to a target node.
References have a specific label, like: &#8220;contains&#8221;, &#8220;has_author&#8221;, etc.
There a two basic types:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">reference-to-one</span></code>: References which exist only once</li>
<li><code class="docutils literal"><span class="pre">reference-to-many</span></code>: References exists zero to many times</li>
</ul>
<p>What constitutes a node and what constitutes a reference is a
design decision made on the content design level.</p>
<p>It is often convenient to talk about nodes as <code class="docutils literal"><span class="pre">vertices</span></code> and
references as <code class="docutils literal"><span class="pre">edges</span></code> in a graph.</p>
<p class="last">References are implemented as python attributes containing object
references. (The term &#8220;reference&#8221; exists both on the data model
level and on the implementation level.) A reference can either
connect to a target node, or to a container of target nodes (list,
set, ...).</p>
</dd>
<dt><code class="docutils literal"><span class="pre">essence</span></code></dt>
<dd><p class="first">Some references are &#8220;essential&#8221; to a source node, and some are
not.  The essence of a node is the total of all nodes in the
transitive hull of all essential references (i.e. all target nodes
of essential references, and all targets of the essential
references of those target nodes, and so on).</p>
<p class="last">The concept of essence is important for change management and will
be discussed in detail below.  The idea is that if a node Y is in
the essence of node X, and Y changes, X &#8220;naturally&#8221; changes with
Y.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">dependents</span></code></dt>
<dd>The inverse essence of a node up to reflexivity: A node X is a
dependent of Y if Y is in the essence of X, but not X itself.</dd>
<dt><code class="docutils literal"><span class="pre">content</span> <span class="pre">node</span></code></dt>
<dd>A node that is self-contained, i.e. it has no outgoing references.
(Content nodes are the leaves of the reference graph.)</dd>
<dt><code class="docutils literal"><span class="pre">follows</span></code></dt>
<dd>Change management is implemented by <code class="docutils literal"><span class="pre">follows</span></code> edges between
nodes.  A node that changes in fact is copied into a new version
that follows the previous version.  <code class="docutils literal"><span class="pre">follows</span></code> edges are NOT
references (neither on the design level nor on the implementation
level).</dd>
</dl>
<p><code class="docutils literal"><span class="pre">head</span></code> A node without outgoing <code class="docutils literal"><span class="pre">follows</span></code> edges</p>
<p><code class="docutils literal"><span class="pre">fork</span></code> A node with more than one outgoing <code class="docutils literal"><span class="pre">follows</span></code> edges.</p>
<p><code class="docutils literal"><span class="pre">merge</span></code> A node with more than one incomming <code class="docutils literal"><span class="pre">follows</span></code> edges.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">relation</span></code></dt>
<dd>A pattern of references and nodes that have a certain
meaning. (See below for examples.)</dd>
</dl>
</div>
<div class="section" id="non-mutability">
<h2>Non-Mutability<a class="headerlink" href="#non-mutability" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This section describes rules and properties that we define for adhocracy
core. They are not enforced by the underlying db.</p>
</div>
<p>The properties contained in a node don&#8217;t change after creation of the node. The
same goes for properties of references. Also, created nodes and references don&#8217;t
ever get deleted.</p>
<p>The set of outgoing references from a node is not allowed to change. The set of
incoming references can change. This also means that a reference from A to B
implies that A is younger or equally old than B.</p>
<div class="section" id="some-intuition">
<h3>Some Intuition<a class="headerlink" href="#some-intuition" title="Permalink to this headline">¶</a></h3>
<p>Imagine you have a node, transitively follow all its outgoing references and
collect all the resulting nodes. This gives you the node&#8217;s <code class="docutils literal"><span class="pre">essence</span></code>. Usually,
this will result in a tree of nodes. A reference means (as defined above) that
the referenced nodes are an &#8220;essential part&#8221; of the referencing node. So our
tree of nodes is something like a deep-copy and recursively includes all the
essential parts of our root node.</p>
<p>(Cycles using references are also allowed, so you might not get a tree, but a
sub-graph. This sub-graph will still be a deep-copy in the described sense.)</p>
</div>
</div>
<div class="section" id="versioning">
<h2>Versioning<a class="headerlink" href="#versioning" title="Permalink to this headline">¶</a></h2>
<p>As existing nodes in the graph never change, every node modification creates a new node which is connected to the originating node with a <code class="docutils literal"><span class="pre">follows</span></code> relation. (We haven&#8217;t decided how to implement this follows relation &#8211; it might be a reference or a node. In the following example graphs the <code class="docutils literal"><span class="pre">follows</span></code> relation is represented by a dashed arrow.)</p>
<p>Example 1.0:</p>
<p>The outgoing references will be copied automatically to point
to the old referred nodes.</p>
<p>Example 1.1:</p>
<p>Incoming references have to be treated specially:</p>
<p>Nodes that are the <code class="docutils literal"><span class="pre">dependents</span></code> of the modified node are marked with a pending marker.</p>
<p>Example 1.2:</p>
<p>These nodes are notified and have three options:</p>
<ul>
<li><p class="first">They can confirm the changeset. This means they will be copied and their outgoing references will point to the new versions of the referred nodes. The old version will leave the pending state.</p>
<p>Example 1.3:</p>
</li>
</ul>
<ul>
<li><p class="first">They can reject the changeset. This means, they will leave the pending state, but no new nodes nor references get created. The outgoing references of the formerly pending node will not change and point to old versions of nodes.</p>
<p>Example 1.4:</p>
</li>
</ul>
<ul class="simple">
<li>They can do nothing and keep the pending state. At any later point in time a node can reject or confirm a changeset, probably triggered by some external event, e.g. user interaction.</li>
</ul>
<div class="section" id="forking-and-merging">
<h3>Forking and merging<a class="headerlink" href="#forking-and-merging" title="Permalink to this headline">¶</a></h3>
<p>Modeling versioning in this manner also allows for forking and merging:</p>
<p>Example 2.0:</p>
</div>
<div class="section" id="deletion">
<h3>Deletion<a class="headerlink" href="#deletion" title="Permalink to this headline">¶</a></h3>
<p>In many cases, deletion can be represented in the graph by modifying a referring node and remove some outgoing edges. It is not necessary to delete the referred node.</p>
<p>Example 3.0:</p>
<p>In other cases, it might be necessary to directly delete a node. For this case a special <code class="docutils literal"><span class="pre">deleted</span></code> node is introduced:</p>
<p>Example 3.1:</p>
<p>PROPOSAL: Not sure if this is already the intention, but it might be enough
to have just one universal DELETED node (or NULL node) in the whole graph.
The DELETED node <code class="docutils literal"><span class="pre">follows</span></code> all nodes that have been deleted (multiple
predecessors). Any node that has been deleted points to the DELETED node as
its successor.</p>
</div>
<div class="section" id="history-manipulation">
<h3>History manipulation<a class="headerlink" href="#history-manipulation" title="Permalink to this headline">¶</a></h3>
<p>In some cases it might be necessary to modify or delete existing nodes and references directly, bypassing the versioning mechanism. This violates the non-mutability property and can be seen as a manipulation of the version history.</p>
<p>These manual modifications of the graph have to be done very carefully and could be considered as administrative tasks.</p>
<p>A typical example for such an administrative task is the real deletion of a
node containing illegal content.</p>
</div>
</div>
<div class="section" id="relations">
<h2>Relations<a class="headerlink" href="#relations" title="Permalink to this headline">¶</a></h2>
<p>We defined relations as a pattern of nodes and references that have a specified meaning. Here is an example of a very simple relation:</p>
<p>Example 5.0:</p>
<p>This <code class="docutils literal"><span class="pre">comments</span></code> relation captures the idea, that <code class="docutils literal"><span class="pre">SomeComment</span></code> comments on <code class="docutils literal"><span class="pre">A</span></code>. Also, the direction of the used reference implies, that <code class="docutils literal"><span class="pre">A</span></code> is an essential part of the comment.</p>
<p>Here is another example of a slightly more complex relation:</p>
<p>Example 5.1:</p>
<p>This relation captures the fact, that <code class="docutils literal"><span class="pre">SomeUser</span></code> <code class="docutils literal"><span class="pre">likes</span></code> <code class="docutils literal"><span class="pre">B</span></code>. Again the directed references imply something about the nodes: <code class="docutils literal"><span class="pre">SomeUser</span></code> and <code class="docutils literal"><span class="pre">B</span></code> are essential parts of this <code class="docutils literal"><span class="pre">likes</span></code> node.</p>
<p>Here is how you could model a list:</p>
<p>The list relation allows you to store an ordered sequence of nodes. Again the direction of the used references implies that the elements are essential parts of the list.</p>
<div class="section" id="modelling-data-by-relations">
<h3>Modelling Data by Relations<a class="headerlink" href="#modelling-data-by-relations" title="Permalink to this headline">¶</a></h3>
<p>The process of modelling your data is basically a process of defining relations. When defining a relation you always have to think about the direction of the used references. Here&#8217;s a checklist that might help:</p>
<p>If you define a relation where <code class="docutils literal"><span class="pre">A</span></code> refers to <code class="docutils literal"><span class="pre">B</span></code> in some manner, then the following should hold:</p>
<ul>
<li><p class="first">It makes sense that <code class="docutils literal"><span class="pre">B</span></code> is an essential part of <code class="docutils literal"><span class="pre">A</span></code>.</p>
</li>
<li><p class="first">A modification of B (creating a newer version <code class="docutils literal"><span class="pre">B'</span></code>) potentially leads to a newer version of <code class="docutils literal"><span class="pre">A</span></code> (<code class="docutils literal"><span class="pre">A'</span></code>) by triggering an update notification. The class of <code class="docutils literal"><span class="pre">A</span></code> should know how to handle such an update notification: immediate automatic confirmation, immediate automatic rejection or keeping the pending state and taking means to gather a manual decision.</p>
</li>
<li><p class="first">No other nodes want to refer to the reference itself. If you want to be able to refer to something, you have to model it as a node. If you want to refer to the relation between <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> in our example, you have to add an additional node:</p>
<p>This way you still retain the idea that <code class="docutils literal"><span class="pre">B</span></code> is an essential part of <code class="docutils literal"><span class="pre">A</span></code>.</p>
</li>
<li><p class="first">Look out for reference cycles. If you define relations that make reference cycles very likely, you should reconsider your modelling. The supergraph allows reference cycles, but they certainly smell bad. (See <a class="reference internal" href="#conjoined-nodes">conjoined_nodes</a>.)</p>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Nodes and relations are the means you have to model your data. Don&#8217;t fall back on simple vertices (not nodes) or simple edges (not relations) for this.</p>
</div>
</div>
<div class="section" id="a-common-pitfall">
<h3>A Common Pitfall<a class="headerlink" href="#a-common-pitfall" title="Permalink to this headline">¶</a></h3>
<p>If you model binary relations (something along the lines of &#8220;subject predicate object&#8221;), it&#8217;s tempting to model the predicate as a single reference:</p>
<p>However make sure this is really what you want: Is <code class="docutils literal"><span class="pre">object</span></code> an essential part of <code class="docutils literal"><span class="pre">subject</span></code>? If not, you have to change this to:</p>
</div>
<div class="section" id="a-non-exhaustive-list-of-relations">
<h3>A non-exhaustive list of relations<a class="headerlink" href="#a-non-exhaustive-list-of-relations" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Follows</span></code></dt>
<dd>This is the relation used to connect nodes to its predecessor or
predecessors. This might be modelled like this (we are still undecided on this):</dd>
<dt><code class="docutils literal"><span class="pre">Deletions</span></code></dt>
<dd>Node deletion is realized as a unary relation connected to the deleted
node.</dd>
<dt><code class="docutils literal"><span class="pre">Predicates</span></code></dt>
<dd><p class="first">Predicates are classical subject-predicate-object relations (also called binary relations), expressible as a verb.</p>
<p class="last">Example: <code class="docutils literal"><span class="pre">comments</span></code></p>
</dd>
<dt><code class="docutils literal"><span class="pre">Collections</span></code></dt>
<dd><p class="first">Collections contain parts.</p>
<p>Implemented as a list vertex with references-to-many to parts</p>
<p class="last">Example: <code class="docutils literal"><span class="pre">Set</span></code>, <code class="docutils literal"><span class="pre">List</span></code></p>
</dd>
<dt><code class="docutils literal"><span class="pre">Lists</span></code></dt>
<dd><p class="first">Ordered collections.</p>
<p>Implemented as a collection with ranked edges.</p>
<p class="last">Example: <code class="docutils literal"><span class="pre">Document</span></code></p>
</dd>
<dt><code class="docutils literal"><span class="pre">Conjoined</span> <span class="pre">Nodes</span></code></dt>
<dd><p class="first">Nodes which essentially belong to each other. Once one node is updated, the
other node has to be updated too and vice versa - the nodes are synchronised. This can be achieved through cyclic subgraphs.</p>
<p class="last">Possible examples: Translations, Binational treaties.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">More</span> <span class="pre">complex</span> <span class="pre">relations</span></code></dt>
<dd>Example: Some discussion leads to a set of (proposed) changes.</dd>
</dl>
</div>
</div>
<div class="section" id="implementation-notes">
<h2>Implementation Notes<a class="headerlink" href="#implementation-notes" title="Permalink to this headline">¶</a></h2>
<p>This paragraph is a summary of the data structure discussions on Fri
2013-07-19 and before.  The later sections are obsolete to a varying
extent.</p>
<p>Nodes are implemented as python objects, references as attributes.  In
addition to the attributes, there is a method:</p>
<div class="code python highlight-python"><div class="highlight"><pre>refs(): { &lt;attr&gt; : &lt;node&gt; }
</pre></div>
</div>
<p>that returns a dictionary mapping python strings containing attribute
names to the resp. reference target nodes.  This is interesting
because not all attributes of the node object are references.</p>
<p>The dependents (inverse references, i.e. only direct dependents) are
represented by a method:</p>
<div class="code python highlight-python"><div class="highlight"><pre>deps(): { &lt;node&gt; : { &lt;interface&gt; : [ &lt;attr&gt; ] } }
</pre></div>
</div>
<p>that returns a dictionary mapping nodes to dictionaries, which in turn
map interfaces to lists of reference names (references are implemented
as attributes containing python references).</p>
<p>This way, it is easy to ask an object which other objects are
referencing it.</p>
<p>Alternatively dependents could be implemented as:</p>
<div class="code python highlight-python"><div class="highlight"><pre>deps(): [ (&lt;node&gt;, &lt;interface&gt;, &lt;attr&gt;) ]
</pre></div>
</div>
<p>There should probably also be transitive hulls for references and
dependents, e.g. <code class="docutils literal"><span class="pre">trans_refs()</span></code> and <code class="docutils literal"><span class="pre">trans_deps()</span></code>, which can be
implemented easily in terms of the above methods.  (XXX: is it more
pythonic to say &#8220;function&#8221; instead of &#8220;method&#8221;?)</p>
<p>Change management is modelled by nodes being copied into <code class="docutils literal"><span class="pre">follows</span></code>
nodes.  There is a number of meaningful and desirable ways in which
references can react to changes in referenced and dependent nodes.</p>
<p>If a reference is essential, the target must notify the source of the
reference.  The source then has three options:</p>
<blockquote>
<div><ul class="simple">
<li>create a new version itself, keep the old reference unchanged, and
update the reference in the new version to point to the new version
of the target.  Example: if a paragraph in a document has been
updated, the document should be considered updated as well.</li>
<li>ask the user what to do about the change.  Example: If a user
&#8220;likes&#8221; a node, and the node changes, the user should be able to
decide whether she also likes the new version, or only the previous
version.</li>
<li>ignore the change, keep the reference pointed to the old version of
the target, and do nothing.  Example: Change suggestions: a user wants
to express that she would support a proposal if some changes are made.
This change suggestion refers to one version of the proposal and shouldn&#8217;t
be updated to newer versions.</li>
</ul>
</div></blockquote>
<p>If a reference is not essential, things get more complicated.  The
source node will still be notified of any change in any target (it
always is for all references), but it has more freedom of choice in
what to do, and with that comes more confusion.  Example:</p>
<p>If topics (in wikimedia-speak: categories) are modelled this way,
neither of the options of essiential references are desirable, because
we would always create a new follower node of any topic that touches
any document that has a new version.  We either want to reference only
the head of each document, and always update all references whenever
documents are updated, or we want to reference all versions in the
history of the document.  (If we only reference heads, then what
happens if somebody keeps badges or comments or whatnot on the old
version, refusing to update?  Then the old document, still referenced
by the comment, falls out of the topic category.  Hum.  I think topic
references would need to be copied, not moved.  This would cause a lot
of references.  Perhaps references should be modelled the other way
round, not as &#8220;touched by&#8221;, but as &#8220;touches&#8221;.  But I digress.)</p>
<p>But if we simply keep track of the head of each document, what happens
with forks?  In a naive implementation, only the head created earliest
would keep the topic, and all forks would miss it, because the node
from which they fork would have passed on the reference to the
follower already.</p>
<p>Disallowing target node forks may be sometimes an option, but in this
case it is not.  So there has to be another notification event: If a
node is forked (has one or more followers already, and gets another
one), all follower nodes are traversed, and all dependents of those
nodes are notified of the fork.</p>
<p>The dependents can then decide what to do.  In the topic model above,
the topic node has to visit the new head and reference it as well,
without killing the old reference.  In other cases, it may raise an
exception and thereby disallow forks in target nodes.</p>
<p>This means that some node types are forkable and others are not.
Nodes therefore need an attribute:</p>
<div class="code python highlight-python"><div class="highlight"><pre>forkable : bool
</pre></div>
</div>
<p>Because essential edges guarantee immutability of target nodes, they
are to be preferred over non-essential nodes when modelling
application data.  The following model:</p>
<p>(Essential egdes are blue.)</p>
<p>has a non-essential edge, i.e. the clear update rules of essentiality
do not apply when the user updates her email address.  The following
model gets by with only essential edges:</p>
<p>XXX: Isn&#8217;t change management of graph data structures a problem that
somebody has figured out on a theoretical level yet?</p>
</div>
</div>


          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Tobias Krauthoff.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>